\documentclass[abstracton,a4paper,twocolumn,9pt]{scrartcl}
\def\LASTCHANGED{2007-08-29}    % automatically updated by emacs
\usepackage{url}
\fussy

% Define our layout
\usepackage[hmargin={20mm,25mm},vmargin={15mm,25mm},offset=0pt,nohead]{geometry}
\columnsep 8mm
\hfuzz 1pt

% Pretty-print Haskell code
\usepackage{listings}
\lstloadlanguages{Haskell}
\lstnewenvironment{code}
    {\lstset{}%
      \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}
    \lstset{
      basicstyle=\small\ttfamily,
      flexiblecolumns=false,
      basewidth={0.5em,0.45em},
      literate={-}{{$-$}}1 {+}{{$+$}}1 {=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2
               {>>}{{>>}}2 {>>=}{{>>=}}2
               {\\\\}{{$\setminus\setminus$}}2
               {\\t}{{$\setminus\mbox{t}$}}2
               {\\r}{{$\setminus\mbox{r}$}}2
               {\\n}{{$\setminus\mbox{n}$}}2
               {\\"}{{$\setminus\mbox{"}$}}2
               {\ .\ }{{$\circ$}}3
               {+-}{{+-}}2
    }
\def\PlPl{\ensuremath{+\mkern-4mu+}}
\def\PlPlOp{\ensuremath{<\mkern-12mu+\mkern-4mu+\mkern-12mu>}}

\long\def\ignore#1{}  % for "uninteresting" code

% Set special types consistently
\newcommand{\tool}[1]{\texttt{#1}}
\newcommand{\module}[1]{\texttt{#1}}
\newcommand{\fun}[1]{\textsf{#1}}
\newcommand{\type}[1]{\textsf{#1}}

\begin{code}
claus = test
\end{code}


% Here we go ...
\begin{document}

\title{Strict I/O in Haskell}
\author{Peter Simons $<$simons@cryp.to$>$}
\date{\LASTCHANGED}
\maketitle

\begin{abstract}
  The difference between a clever algorithm and an useful application is
  that the latter communicates with the real world. For example, a
  QuickSort function is inherently useful, but that usefulness becomes
  observable only when an unsorted dataset can be entered into a
  computer program and a sorted dataset comes out. The QuickSort
  function doesn't do that. Almost every user of the Unix shell knows
  the utility \tool{sort} --- but not every one of those people who use
  that utility knows about QuickSort. In other words: I/O matters.
  Programs that perform no I/O are only zeros and ones.

  Unfortunately, the Haskell community appears to regard the subject
  with some suspicion. An experience many have made is that real-world
  applications written in Haskell have a tendency to show underwhelming
  performance characteristics when put to the test in a real-world
  environment. The programs work just fine, but their resource
  consumption is incredible.

  Naturally, this effect is generally blamed on the I/O API, the
  implementation, the compiler's optimizer, or on the language itself.
  There is some truth in all of that, but the core of the problem is
  that most everyday Haskell programs plainly suck at doing efficient
  I/O.

  This article is an investigation of the problem and an attempt to
  outline possible solutions. The presented material will be most useful
  to experienced Haskell programmers who would like to put the world's
  finest imperative language to the task of communicating with the real
  world.
\end{abstract}

\section{I/O in Haskell is slow} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \input{wc-lazy.lhs}




\section{Conclusion} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{9}
    \bibitem{Haskell}
      Haskell --- A Purely Functional Language,
      \url{http://haskell.org/}

\end{thebibliography}

\end{document}

%%%%% configure emacs
%
% Local variables:
% eval: (add-hook 'write-file-hooks 'time-stamp)
% fill-column: 72
% mmm-classes: literate-haskell-latex
% time-stamp-start: "\\LASTCHANGED{"
% time-stamp-format: "%:y-%02m-%02d"
% time-stamp-end: "}"
% time-stamp-line-limit: 5
% End:
