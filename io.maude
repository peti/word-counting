--- Modeling I/O

fth IO-THEORY is
  including NAT .

  sort Ctx State Event .
  op IO : -> Ctx [ctor] .

  sort Source Sink Peer .
  subsort Source Sink < Peer .

  sort Iterator .
endfth

mod IO-SYSTEM{IO :: IO-THEORY} is
  including LIST{String} .

  op Socket : -> IO$Peer [ctor] .
  op socket : Nat -> IO$Ctx [ctor] .
  op input =_ : List{String} -> IO$State [ctor prec 40] .

  op recvMsg : IO$Ctx IO$Ctx IO$Iterator IO$Iterator -> IO$Event .
endm

mod REAL-WORLD is
  including CONFIGURATION .
  including NAT .

  var CTX OID   : Oid .
  var N NOW     : Nat .
  var MSG       : Msg .

  op IO : -> Oid [ctor] .

  op RealWorld : -> Cid [ctor] .
  op tick =_   : Nat -> Attribute [ctor] .

  op recvTick : Oid Oid     -> Msg .
  op sendTick : Oid Oid Nat -> Msg .

  rl [receiveTick]
    :  < CTX : RealWorld | tick = N >   recvTick(CTX, OID)
    => < CTX : RealWorld | tick = s N > sendTick(OID, CTX, N)
    .
endm

view POSIX from IO-THEORY to REAL-WORLD is
  sort Ctx    to Oid .
  sort Event  to Msg .
  sort State  to Attribute .

  sort Source to Cid .
  sort Sink   to Cid .
  sort Peer   to Cid .

  sort Iterator to Nat .
endv

mod MAIN is
  including IO-SYSTEM{POSIX} .
  including STRING .

  op Handler : -> Cid .
  op ptr_ : NzNat -> Oid [ctor] .

  ops stdin stdout stderr : -> Oid [ctor] .
  eq stdin  = socket(0) .
  eq stdout = socket(1) .
  eq stderr = socket(2) .

  op Iovec    : -> Cid [ctor] .
  op iovec =_ : String -> Attribute [ctor prec 40] .
  op gap =_   : Nat -> Attribute [ctor prec 40] .
  op space =_ : Nat -> Attribute [ctor prec 40] .

  var CTX OID : Oid .
  var BUF IOV : String .
  var AS : AttributeSet .
  var N I : Nat .
  var EV1 EV2 : Msg .

  op pushBack : Oid Oid String -> Msg .
  op return  : Oid Oid -> Msg .

  eq  < CTX : Iovec | AS > pushBack(CTX, OID, "")
    = < CTX : Iovec | AS > return(OID, CTX)
    .

  rl [pushBack]
    :  pushBack(CTX, OID, BUF)
       < CTX : Iovec | AS, iovec = IOV, space = s(N) >
    => < CTX : Iovec | AS, iovec = IOV + substr(BUF, 0, 1)
                         , space = N >
       pushBack(CTX, OID, substr(BUF, 1, length(BUF)))
    .

  op popFront : Oid Oid Nat    -> Msg .
  op dropped  : Oid Oid String -> Msg .

  eq  < CTX : Iovec | AS > popFront(CTX, OID, 0)
    = < CTX : Iovec | AS > return(OID, CTX)
    .

  rl [popFront]
    :  popFront(CTX, OID, s(I))
       < CTX : Iovec | AS, iovec = IOV, gap = N >
    => < CTX : Iovec | AS, iovec = substr(IOV, 1, length(IOV)),
                           gap   = s(N) >
       popFront(CTX, OID, I)
    .

  ops inbuf outbuf : -> Oid .

  op main : -> Configuration .
  eq main = <>
    < IO     : RealWorld | tick = 0 >
    < stdin  : Socket    | input = "hello" "wor" "ld" >
    < inbuf  : Iovec     | gap = 0, space = 1024, iovec = "" >
    < ptr 1  : Handler   | none >
    recvMsg(stdin, inbuf, 0, 10)
    .
endm
